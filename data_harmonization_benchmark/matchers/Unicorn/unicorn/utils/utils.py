# -*- coding : utf-8 -*-\n# coding: unicode_escape\nimport csv\nimport json\nimport os\nimport random\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport torch\nimport torch.backends.cudnn as cudnn\nfrom unicorn.utils import param\n\n\nclass AttrDict(dict):\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\n\ndef read_csv(input_file):\n    """Reads a tab separated value file."""\n    with open(input_file, "r", encoding="gbk", errors="ignore") as f:\n        reader = csv.reader(f)\n        lines = []\n        for line in reader:\n            lines.append(line)\n        return lines[1:]\n\n\ndef norm(s):\n    s = s.replace(",", " ")\n    return s\n\n\ndef getstr(id, data):\n    for x in data:\n        if str(id) == str(x[0]):\n            return norm(" ".join(x[1:]))\n\n\ndef read_data_from_raw(af, bf, goldf):\n    a = read_csv(af)\n    b = read_csv(bf)\n    g = read_csv(goldf)\n    pos = 0\n    neg = 0\n    res = []\n    for x in g:\n        x[0], x[1] = int(x[0]), int(x[1])\n    for x in g[:2000]:\n        lst = getstr(x[0], a)\n        rst = getstr(x[1], b)\n        res.append([lst, rst, 1])\n        pos += 1\n        fake = x[1] + 1\n        while [x[0], fake] in g:\n            fake += 1\n        lst = getstr(x[0], a)\n        rst = getstr(fake, b)\n        res.append([lst, rst, 0])\n        neg += 1\n    print("pos ", pos)\n    print("neg ", neg)\n    return res\n\n\ndef save_to_csv(filename, data):\n    with open(filename, "w", newline="") as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerows(data)\n\n\ndef get_data(filename, num=-1):\n    data = json.load(open(filename, encoding="utf-8"))\n    if num != -1 and num < len(data):\n        random.seed(42)\n        data = random.sample(data, num)\n    return data\n\n\ndef save_json(outname, data):\n    with open(outname, "w", encoding="utf-8") as file_obj:\n        json.dump(data, file_obj, ensure_ascii=False)\n\n\nclass InputFeatures(object):\n    def __init__(self, input_ids, input_mask, segment_ids, label_id, exm_id):\n        self.input_ids = input_ids\n        self.input_mask = input_mask\n        self.segment_ids = segment_ids\n        self.label_id = label_id\n        self.exm_id = exm_id\n\n\ndef CSV2Array(path):\n    data = pd.read_csv(path, encoding="latin")\n    reviews, labels = data.reviews.values.tolist(), data.labels.values.tolist()\n    return reviews, labels\n\n\ndef make_cuda(tensor):\n    if torch.cuda.is_available():\n        tensor = tensor.cuda()\n    return tensor\n\n\ndef init_random_seed(manual_seed):\n    if manual_seed is None:\n        seed = random.randint(1, 10000)\n    else:\n        seed = manual_seed\n    print("use random seed: {}".format(seed))\n    random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed_all(seed)\n\n\ndef init_model(net, restore=None):\n    # restore model weights\n    if restore is not None:\n        path = os.path.join(param.model_root, restore)\n        if os.path.exists(path):\n            net.load_state_dict(torch.load(path))\n            print("Restore model from: {}".format(os.path.abspath(path)))\n\n    # check if cuda is available\n    if torch.cuda.is_available():\n        cudnn.benchmark = True\n        net.cuda()\n    return net\n\n\ndef save_model(net, name):\n    folder = param.model_root\n    path = os.path.join(folder, name)\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    torch.save(net.state_dict(), path)\n    print("save pretrained model to: {}".format(path))\n\n\ndef draw_f1_line(datas, path):\n    x = [i + 1 for i in range(len(datas[0]))]\n    plt.title("F1 score")\n    plt.rcParams["font.sans-serif"] = ["SimHei"]\n    plt.xlabel("Epoch")\n    plt.ylabel("F1")\n    for i, y in enumerate(datas):\n        plt.plot(x, y, marker="o", markersize=3, label="task" + str(i))\n    plt.legend(loc="best", frameon=False)\n    plt.show()\n    plt.savefig(path)\n